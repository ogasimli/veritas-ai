---
phase: 07-frontend-dashboard
plan: 03
type: execute
---

<objective>
Implement real-time WebSocket integration with live agent status cards and findings display.

Purpose: Connect frontend to FastAPI WebSocket server, display live agent progress and findings as analysis runs, creating the core real-time experience.
Output: Working WebSocket connection showing four agent cards (Numeric, Logic, Disclosure, External) with live findings updates.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-frontend-dashboard/07-CONTEXT.md
@.planning/phases/07-frontend-dashboard/07-RESEARCH.md
@.planning/phases/07-frontend-dashboard/07-02-SUMMARY.md
@frontend/app/(dashboard)/audit/new/page.tsx
@frontend/lib/api.ts

**From CONTEXT.md:**
- Real-time WebSocket experience is essential
- Inline transformation: upload → processing → results on same page
- Four agent cards: Numeric, Logic, Disclosure, External
- Each card starts with indeterminate spinner
- Findings appear in card immediately as agent produces them
- When agent completes, spinner disappears
- If agent fails, show simple error message "Processing failed"
- No page navigation - UI morphs in place

**From RESEARCH.md:**
- Use NATIVE WebSocket API (NOT Socket.IO, not next-ws)
- Connect to FastAPI WebSocket server: `ws://localhost:8000/ws/audit/{auditId}`
- WebSocket connection in useEffect hook
- Handle onopen, onmessage, onerror, onclose events
- Always clean up WebSocket in useEffect cleanup (close connection)
- Message types from FastAPI: 'finding', 'agent_status', 'complete'
- Example code in RESEARCH.md shows connection pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket hook for audit connection</name>
  <files>frontend/hooks/use-audit-websocket.ts, frontend/lib/types.ts</files>
  <action>
Create custom hook at `frontend/hooks/use-audit-websocket.ts`:
- Mark file with 'use client' directive
- Import useEffect, useRef, useState, useCallback from react
- Define Finding type: {id, agent, severity, title, description}
- Define AgentStatus type: {agent, status: 'idle' | 'processing' | 'complete' | 'error'}
- Export useAuditWebSocket hook taking auditId parameter
- Create WebSocket connection to `ws://localhost:8000/ws/audit/${auditId}` in useEffect
- Track connectionStatus state: 'connecting' | 'connected' | 'disconnected'
- Track findings array state
- Track agentStatuses object state (keyed by agent name)
- Handle onopen: set connectionStatus to 'connected'
- Handle onmessage: parse JSON, switch on message type
  - 'finding': add to findings array
  - 'agent_status': update agentStatuses object
  - 'complete': log completion
- Handle onerror: set connectionStatus to 'disconnected'
- Handle onclose: set connectionStatus to 'disconnected'
- Return cleanup function that closes WebSocket
- Return {findings, agentStatuses, connectionStatus, reconnect}

Create types file at `frontend/lib/types.ts`:
- Export Finding type
- Export AgentStatus type
- Export Audit type: {id, name, status, createdAt, updatedAt}

Use NATIVE WebSocket API (NOT Socket.IO - FastAPI doesn't use it). Always include cleanup function in useEffect to prevent memory leaks.
  </action>
  <verify>Hook file compiles without TypeScript errors. Import in test component - WebSocket connection attempts to connect (may fail if backend not running, that's expected).</verify>
  <done>useAuditWebSocket hook created with WebSocket connection logic. Types defined. Cleanup function prevents memory leaks. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create agent card components with live updates</name>
  <files>frontend/components/audit/agent-card.tsx, frontend/app/(dashboard)/audit/new/page.tsx</files>
  <action>
Create AgentCard component at `frontend/components/audit/agent-card.tsx`:
- Mark with 'use client'
- Import Finding, AgentStatus types from @/lib/types
- Accept props: agent (enum), status, findings array
- Define AGENT_CONFIG mapping agent names to labels, icons, colors:
  - 'numeric': {label: 'Numeric Validation', icon: 'calculate', color: 'blue'}
  - 'logic': {label: 'Logic Consistency', icon: 'account_tree', color: 'purple'}
  - 'disclosure': {label: 'Disclosure Compliance', icon: 'policy', color: 'orange'}
  - 'external': {label: 'External Signals', icon: 'public', color: 'teal'}
- Render card with header showing agent label + icon
- If status='processing': show indeterminate spinner (animate-spin, NOT progress bar)
- If status='complete' and findings.length=0: show "No issues found" with green checkmark
- If status='complete' and findings.length>0: render findings list
  - Each finding: border-left-4 with severity color (red=critical, amber=warning, green=pass)
  - Show title + description
  - No click interaction (read-only per CONTEXT.md)
- If status='error': show "Processing failed" message
- Style per CONTEXT.md mockup: card with border, agent icon, severity badges

Update `frontend/app/(dashboard)/audit/new/page.tsx`:
- Import useAuditWebSocket hook
- Call hook with auditId (generate temp ID or get from URL)
- Destructure {findings, agentStatuses, connectionStatus}
- Replace "Live Findings Monitor" empty state with four AgentCard components
- Pass filtered findings to each card (findings.filter(f => f.agent === agentName))
- Pass agent status from agentStatuses object
- Show connection status indicator at top (optional, subtle)

Do NOT add percentage-based progress bars (use indeterminate spinners per CONTEXT.md). Do NOT add drill-down modals (out of scope per CONTEXT.md). Findings are read-only text display only.
  </action>
  <verify>Visit /audit/new. Four agent cards render. If backend running and WebSocket connected, cards show "processing" spinners. If findings arrive via WebSocket, they appear in cards immediately. No console errors.</verify>
  <done>AgentCard component renders agent status and findings. Live updates work when WebSocket receives messages. Indeterminate spinners used. No drill-down interactions.</done>
</task>

<task type="auto">
  <name>Task 3: Wire "Start Review" button to trigger processing and show live UI</name>
  <files>frontend/app/(dashboard)/audit/new/page.tsx, frontend/lib/api.ts</files>
  <action>
Update audit creation page:
- Add processingStarted state (boolean, default false)
- On "Start Review" click:
  - Call API to create audit and upload files
  - Get audit ID from response
  - Set processingStarted = true
  - Call API to start processing: POST /api/audits/{id}/process
  - Initiate WebSocket connection with returned audit ID
- Inline transformation (per CONTEXT.md):
  - When processingStarted = false: show upload zones + "Start Review" button
  - When processingStarted = true: hide upload zones, show compact "Data Sources" chips at top, show four agent cards
- Upload zones shrink into compact chips showing filename + green checkmark
- "Start Review" button disappears
- Four agent cards appear with spinners
- All happens on same page (NO navigation, NO new route)

Update `frontend/lib/api.ts`:
- Add startProcessing function: POST /api/audits/{id}/process
- Returns 200 OK when processing initiated
- Backend will send WebSocket updates as processing happens

Handle WebSocket connection lifecycle:
- Only connect after processingStarted = true
- Show subtle "Connecting..." indicator if connectionStatus = 'connecting'
- If connection fails, show error message with reconnect button
- Keep error handling simple: just show "Connection failed. Retry?" (per CONTEXT.md)

Do NOT navigate to new page/route (inline transformation per CONTEXT.md). Do NOT show audit score card (removed from scope per CONTEXT.md).
  </action>
  <verify>Click "Start Review" button. Upload zones transform into compact chips at top. Four agent cards appear with spinners. Page doesn't navigate. WebSocket connection status shown. Build succeeds.</verify>
  <done>"Start Review" triggers inline transformation. Upload → Processing happens on same page. WebSocket connection established. Agent cards update live. No navigation.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build --prefix frontend` succeeds without errors
- [ ] Upload files in /audit/new, click "Start Review"
- [ ] Upload zones transform into compact "Data Sources" chips (inline, no navigation)
- [ ] Four agent cards appear with spinning indicators
- [ ] WebSocket connection established (check DevTools Network tab)
- [ ] If backend sends findings, they appear in cards immediately
- [ ] No percentage-based progress bars (only indeterminate spinners)
- [ ] Connection status visible (subtle indicator)
- [ ] No console errors or WebSocket memory leaks
- [ ] Closing/refreshing page cleans up WebSocket connection
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript or build errors
- WebSocket integration works with FastAPI backend
- Real-time findings display updates live
- Inline transformation (upload → processing) works without navigation
- Ready for export functionality and polish (07-04)
</success_criteria>

<output>
After completion, create `.planning/phases/07-frontend-dashboard/07-03-SUMMARY.md`:

# Phase 7 Plan 3: WebSocket Integration Summary

**Real-time WebSocket connection with live agent cards and findings display implemented.**

## Accomplishments

- Created useAuditWebSocket custom hook with native WebSocket API
- Built AgentCard component showing status and findings
- Implemented inline transformation (upload → processing → results)
- Wired "Start Review" button to start processing and initiate WebSocket
- Four agent cards display live with indeterminate spinners
- Findings appear in real-time as agents produce them
- WebSocket cleanup prevents memory leaks

## Files Created/Modified

- `frontend/hooks/use-audit-websocket.ts` - WebSocket connection hook
- `frontend/lib/types.ts` - TypeScript types for Finding, AgentStatus, Audit
- `frontend/components/audit/agent-card.tsx` - Agent status card component
- `frontend/app/(dashboard)/audit/new/page.tsx` - Inline transformation logic
- `frontend/lib/api.ts` - startProcessing API function

## Decisions Made

- Used native WebSocket API (not Socket.IO - FastAPI doesn't use it)
- Inline transformation on same page (no navigation per CONTEXT.md)
- Indeterminate spinners only (no percentage progress per CONTEXT.md)
- Simple error handling: "Connection failed. Retry?" (per CONTEXT.md)
- Read-only findings (no drill-down per CONTEXT.md)

## Issues Encountered

None

## Next Step

Ready for 07-04-PLAN.md: Export functionality and final polish
</output>
