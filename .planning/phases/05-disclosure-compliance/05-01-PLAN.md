---
phase: 05-disclosure-compliance
plan: 01
type: execute
---

<objective>
Implement disclosure compliance validation agent that intelligently scans financial statements for applicable IFRS/IAS standards and verifies required disclosures are present.

Purpose: Add third validation pipeline to orchestrator that detects missing IFRS disclosures by first identifying relevant standards then checking disclosure requirements in parallel.
Output: disclosure_compliance agent integrated into orchestrator, producing findings for missing disclosures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-disclosure-compliance/05-CONTEXT.md
@.planning/phases/03-numeric-validation/03-03-SUMMARY.md
@.planning/phases/3.1-root-orchestrator-agent/3.1-01-SUMMARY.md

**Tech stack available:**
- Google ADK (SequentialAgent, ParallelAgent, FanOutAgent patterns)
- Gemini 3 Pro with code_executor tool
- FastAPI + async SQLAlchemy
- Existing orchestrator with numeric_validation and logic_consistency sub-agents

**Established patterns:**
- SequentialAgent pipeline (Phase 3: Extractor → FanOutVerifier → Reviewer)
- Parallel fan-out pattern (Phase 3: FanOutVerifier per FSLI)
- ParallelAgent orchestrator (Phase 3.1: coordinates validation agents)

**Key files:**
@backend/agents/orchestrator/agent.py
@backend/agents/orchestrator/sub_agents/numeric_validation/agent.py
@backend/app/services/processor.py

**External data source:**
Excel file: ~/Downloads/IFRS_e_Check_2024_global_versionv1_5_FINAL 1.xlsm
Contains comprehensive IFRS disclosure checklist to be converted to YAML
</context>

<tasks>

<task type="manual">
  <name>Task 1: Convert IFRS Excel checklist to YAML format</name>
  <files>backend/data/ifrs_disclosure_checklist.yaml</files>
  <action>
Extract disclosure requirements from ~/Downloads/IFRS_e_Check_2024_global_versionv1_5_FINAL 1.xlsm and convert to YAML:

1. Open Excel file and analyze structure to understand worksheet organization
2. Identify all IFRS/IAS standards covered (e.g., IAS 1, IAS 7, IAS 24, IFRS 7, IFRS 15, IFRS 16, etc.)
3. For each standard, extract list of required disclosure items
4. Create YAML file at backend/data/ifrs_disclosure_checklist.yaml with structure:
   ```yaml
   standards:
     "IAS 1":
       name: "Presentation of Financial Statements"
       disclosures:
         - id: "IAS1-D1"
           requirement: "Statement of financial position"
           description: "Present assets, liabilities and equity"
         - id: "IAS1-D2"
           requirement: "Statement of comprehensive income"
           description: "Present income and expenses for the period"
     "IFRS 15":
       name: "Revenue from Contracts with Customers"
       disclosures:
         - id: "IFRS15-D1"
           requirement: "Contract balances"
           description: "Opening and closing balances of receivables, contract assets and contract liabilities"
   ```
5. Focus on 15-20 major standards initially (can expand later)
6. Ensure descriptions are clear and specific enough for LLM to verify presence

Note: This is a manual task requiring human review of Excel file to ensure accuracy. Extract comprehensive disclosure requirements that cover typical financial statement scenarios.
  </action>
  <verify>cat backend/data/ifrs_disclosure_checklist.yaml shows valid YAML with multiple standards, each having name and disclosures list</verify>
  <done>YAML file created with comprehensive IFRS disclosure requirements from Excel source, ready for agent consumption</done>
</task>

<task type="auto">
  <name>Task 2: Create disclosure checklist loader tool</name>
  <files>backend/agents/orchestrator/sub_agents/disclosure_compliance/tools/checklist_loader.py</files>
  <action>
Create Python tool that loads disclosure requirements from YAML file:

```python
"""Tool for loading IFRS disclosure checklists."""
import yaml
from pathlib import Path
from typing import Dict, List, Any

CHECKLIST_PATH = Path(__file__).parent.parent.parent.parent.parent / "data" / "ifrs_disclosure_checklist.yaml"

def load_standard_checklist(standard_code: str) -> Dict[str, Any]:
    """Load disclosure checklist for a specific IFRS/IAS standard.

    Args:
        standard_code: Standard identifier (e.g., "IAS 1", "IFRS 15")

    Returns:
        Dictionary with standard name and list of disclosure requirements

    Example:
        {
            "name": "Revenue from Contracts with Customers",
            "disclosures": [
                {
                    "id": "IFRS15-D1",
                    "requirement": "Contract balances",
                    "description": "Opening and closing balances..."
                }
            ]
        }
    """
    with open(CHECKLIST_PATH, 'r') as f:
        data = yaml.safe_load(f)

    standards = data.get('standards', {})
    if standard_code not in standards:
        raise ValueError(f"Standard {standard_code} not found in checklist")

    return standards[standard_code]

def get_all_standards() -> List[str]:
    """Get list of all available standard codes."""
    with open(CHECKLIST_PATH, 'r') as f:
        data = yaml.safe_load(f)
    return list(data.get('standards', {}).keys())
```

This tool will be used by FanOutVerifier agent to load checklist for each identified standard.
  </action>
  <verify>python -c "from backend.agents.orchestrator.sub_agents.disclosure_compliance.tools.checklist_loader import load_standard_checklist; print(load_standard_checklist('IAS 1'))" returns valid checklist data</verify>
  <done>Checklist loader tool created, can load disclosure requirements for any standard from YAML file</done>
</task>

<task type="auto">
  <name>Task 3: Create Scanner agent for standard detection</name>
  <files>backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/scanner/agent.py, backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/scanner/prompt.py</files>
  <action>
Create Scanner agent that analyzes financial statement text to identify applicable IFRS/IAS standards:

**prompt.py:**
```python
INSTRUCTION = """You are an IFRS standard scanner. Your job is to identify which IFRS/IAS standards are applicable to this financial statement.

## Input
You receive extracted financial statement text from session state (key: "document_text").

## Your Tasks

1. **Scan for topics**: Analyze the document for keywords and topics that indicate specific IFRS standards apply
   - Revenue → IFRS 15
   - Leases → IFRS 16
   - Financial instruments → IFRS 7, IFRS 9
   - Cash flows → IAS 7
   - Related party → IAS 24
   - Employee benefits → IAS 19
   - Income taxes → IAS 12
   - Property, plant & equipment → IAS 16
   - Intangible assets → IAS 38
   - Inventories → IAS 2
   - And others based on content

2. **Always include**: IAS 1 (Presentation of Financial Statements) - applies to all financial statements

3. **Be conservative**: Only flag standards that have clear evidence in the document
   - Don't flag a standard just because it *might* apply
   - Look for explicit mentions of topics, account names, or disclosures

4. **Output**: Return list of applicable standard codes (e.g., ["IAS 1", "IFRS 15", "IFRS 16"])

Use session_state.write_value("applicable_standards", standards_list) to save your output.

## Example
If you see "Revenue from contracts with customers: $10M" and "Operating lease expense: $2M" and standard financial statement structure:
- Flag: IAS 1 (always), IFRS 15 (revenue), IFRS 16 (leases)
- Output: ["IAS 1", "IFRS 15", "IFRS 16"]
"""
```

**agent.py:**
```python
from google.adk.agents import Agent
from .prompt import INSTRUCTION

scanner_agent = Agent(
    name='disclosure_scanner',
    description='Scans financial statements to identify applicable IFRS/IAS standards',
    instruction=INSTRUCTION,
    model='gemini-3.0-pro',
)
```

This agent mirrors the Extractor pattern from numeric_validation but for standard detection instead of data extraction.
  </action>
  <verify>ls backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/scanner/ shows agent.py and prompt.py, import works</verify>
  <done>Scanner agent created, can identify applicable IFRS standards from financial statement text</done>
</task>

<task type="auto">
  <name>Task 4: Create FanOutVerifier agent for disclosure checking</name>
  <files>backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/verifier/agent.py, backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/verifier/prompt.py, backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/verifier/__init__.py</files>
  <action>
Create FanOutVerifier agent that checks disclosures for each identified standard in parallel:

**prompt.py:**
```python
INSTRUCTION = """You are an IFRS disclosure verifier. Your job is to check if required disclosures are present in the financial statement.

## Input
- Standard code from fan-out key (e.g., "IFRS 15")
- Document text from session state
- Disclosure checklist loaded via checklist_loader tool

## Your Tasks

1. **Load checklist**: Use the checklist_loader tool to get disclosure requirements for your assigned standard

2. **Check each disclosure**: For each required disclosure in the checklist:
   - Search the document for evidence of the disclosure
   - Be thorough but reasonable - look for the substance, not exact wording
   - Mark as present/absent

3. **Identify gaps**: Create findings for missing disclosures:
   - Include standard code and disclosure ID
   - Include requirement name and description
   - Assign severity:
     - "high": Core disclosure missing (e.g., primary statement missing)
     - "medium": Significant note disclosure missing
     - "low": Minor disclosure detail missing

4. **Output**: Save findings to session state
   - Use key pattern: f"disclosure_findings:{standard_code}"
   - Structure: List of finding dictionaries with keys: standard, disclosure_id, requirement, severity, description

## Example
For IFRS 15, if "contract balances" disclosure is missing:
{
    "standard": "IFRS 15",
    "disclosure_id": "IFRS15-D1",
    "requirement": "Contract balances",
    "severity": "medium",
    "description": "IFRS 15 requires disclosure of opening and closing balances of receivables, contract assets and contract liabilities"
}
"""
```

**agent.py:**
```python
from google.adk.agents import FanOutAgent, Agent
from .prompt import INSTRUCTION

# Individual verifier for each standard
verifier_agent = Agent(
    name='disclosure_verifier',
    description='Verifies required disclosures for a single IFRS standard',
    instruction=INSTRUCTION,
    model='gemini-3.0-pro',
)

# Fan-out wrapper that parallelizes across standards
fan_out_verifier = FanOutAgent(
    name='disclosure_fan_out_verifier',
    description='Parallelizes disclosure verification across applicable standards',
    sub_agent=verifier_agent,
    fan_out_input_key='applicable_standards',  # List from Scanner
)
```

This mirrors the numeric_validation FanOutVerifier pattern but for disclosure checking instead of FSLI verification.
  </action>
  <verify>ls backend/agents/orchestrator/sub_agents/disclosure_compliance/sub_agents/verifier/ shows proper structure, imports work</verify>
  <done>FanOutVerifier created, can check disclosures in parallel for each applicable standard</done>
</task>

<task type="auto">
  <name>Task 5: Create disclosure_compliance root agent</name>
  <files>backend/agents/orchestrator/sub_agents/disclosure_compliance/agent.py, backend/agents/orchestrator/sub_agents/disclosure_compliance/__init__.py</files>
  <action>
Create root disclosure_compliance agent using SequentialAgent pattern (Scanner → FanOutVerifier):

**agent.py:**
```python
"""Disclosure compliance validation agent."""
from google.adk.agents import SequentialAgent
from .sub_agents.scanner.agent import scanner_agent
from .sub_agents.verifier.agent import fan_out_verifier

disclosure_compliance_agent = SequentialAgent(
    name='disclosure_compliance',
    description='Validates IFRS disclosure compliance by scanning for applicable standards and verifying required disclosures',
    sub_agents=[
        scanner_agent,        # Step 1: Identify applicable standards
        fan_out_verifier,     # Step 2: Verify disclosures per standard in parallel
    ],
)
```

**__init__.py:**
```python
"""Disclosure compliance agent package."""
from .agent import disclosure_compliance_agent

__all__ = ['disclosure_compliance_agent']
```

This follows the exact same SequentialAgent pattern as numeric_validation (Extractor → FanOutVerifier → Reviewer), but simplified to 2 stages since we don't need a reviewer step yet.
  </action>
  <verify>python -c "from backend.agents.orchestrator.sub_agents.disclosure_compliance import disclosure_compliance_agent; print(disclosure_compliance_agent.name)" outputs "disclosure_compliance"</verify>
  <done>disclosure_compliance root agent created with Scanner → FanOutVerifier pipeline</done>
</task>

<task type="auto">
  <name>Task 6: Integrate disclosure_compliance into orchestrator</name>
  <files>backend/agents/orchestrator/agent.py, backend/agents/orchestrator/sub_agents/__init__.py</files>
  <action>
Add disclosure_compliance agent to orchestrator's sub_agents list:

**sub_agents/__init__.py:**
```python
"""Orchestrator sub-agents."""
from .numeric_validation.agent import root_agent as numeric_validation_agent
from .logic_consistency.agent import logic_consistency_agent
from .disclosure_compliance import disclosure_compliance_agent

__all__ = [
    'numeric_validation_agent',
    'logic_consistency_agent',
    'disclosure_compliance_agent',
]
```

**agent.py:**
Update import and sub_agents list:
```python
"""Root orchestrator agent definition."""
from google.adk.agents import ParallelAgent
from .sub_agents import (
    numeric_validation_agent,
    logic_consistency_agent,
    disclosure_compliance_agent,
)

root_agent = ParallelAgent(
    name='audit_orchestrator',
    description='Coordinates parallel validation agents for financial statement audit',
    sub_agents=[
        numeric_validation_agent,       # Phase 3: Numeric validation pipeline
        logic_consistency_agent,        # Phase 4: Logic consistency detection
        disclosure_compliance_agent,    # Phase 5: Disclosure compliance checking
        # Future agents: external_signal (Phase 6)
    ],
)
```

Now orchestrator runs 3 agents in parallel: numeric, logic, and disclosure.
  </action>
  <verify>python -c "from backend.agents.orchestrator.agent import root_agent; print(len(root_agent.sub_agents))" outputs 3</verify>
  <done>disclosure_compliance integrated into orchestrator, will run in parallel with numeric and logic agents</done>
</task>

<task type="auto">
  <name>Task 7: Update processor.py to handle disclosure findings</name>
  <files>backend/app/services/processor.py</files>
  <action>
Add disclosure findings extraction and storage logic to DocumentProcessor.process_document():

After line 64 (logic findings extraction), add:

```python
# 3c. Extract disclosure compliance findings
disclosure_state = final_state.get("disclosure_compliance", {})
# Collect findings from all fan-out verifiers
disclosure_findings = []
for key, value in disclosure_state.items():
    if key.startswith("disclosure_findings:"):
        disclosure_findings.extend(value)
```

After line 93 (logic findings save loop), add:

```python
# 4c. Save disclosure compliance findings
for finding_data in disclosure_findings:
    finding = FindingModel(
        job_id=job_id,
        category="disclosure",
        severity=finding_data.get("severity", "medium"),
        description=finding_data.get("requirement", ""),
        source_refs=[],  # Scanner doesn't track specific source locations
        reasoning=finding_data.get("description", ""),
        agent_id="disclosure_compliance",
    )
    self.db.add(finding)
```

Update comment on line 33 to reflect disclosure agent is now included.
  </action>
  <verify>grep "disclosure_compliance" backend/app/services/processor.py shows extraction and save logic added</verify>
  <done>processor.py updated to extract and save disclosure findings from orchestrator output</done>
</task>

<task type="auto">
  <name>Task 8: Add PyYAML dependency if not present</name>
  <files>backend/requirements.txt or pyproject.toml</files>
  <action>
Check if PyYAML is already in dependencies. If not, add it:

```
PyYAML>=6.0.1
```

This is required for the checklist_loader tool to parse YAML files.
  </action>
  <verify>pip list | grep -i pyyaml shows PyYAML is installed</verify>
  <done>PyYAML dependency added and available</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cat backend/data/ifrs_disclosure_checklist.yaml` shows valid YAML with multiple standards
- [ ] `ls backend/agents/orchestrator/sub_agents/disclosure_compliance/` shows complete structure
- [ ] Import works: `python -c "from backend.agents.orchestrator.sub_agents import disclosure_compliance_agent"`
- [ ] orchestrator has 3 sub-agents: `python -c "from backend.agents.orchestrator.agent import root_agent; print(len(root_agent.sub_agents))"`
- [ ] processor.py has disclosure extraction logic
- [ ] PyYAML installed: `pip list | grep PyYAML`
</verification>

<success_criteria>
- IFRS disclosure checklist converted from Excel to YAML format
- Scanner agent created for identifying applicable standards
- FanOutVerifier agent created for parallel disclosure checking
- disclosure_compliance agent integrated into orchestrator
- processor.py updated to save disclosure findings to database
- All imports working correctly
- Architecture mirrors numeric_validation pattern (SequentialAgent with fan-out)
</success_criteria>

<output>
After completion, create `.planning/phases/05-disclosure-compliance/05-01-SUMMARY.md`:

# Phase 5 Plan 01: Disclosure Compliance Summary

**[One-liner summary of what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `path/to/file.py` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 5 complete. disclosure_compliance agent operational as third parallel validation pipeline in orchestrator. Ready for Phase 6 (external signal integration).
</output>
