---
phase: 03-numeric-validation
plan: 03-03
type: execute
domain: agents
---

<objective>
Create the Manager agent for aggregation, build the SequentialAgent pipeline, and integrate into document processing flow.

Purpose: Complete the numeric validation pipeline and connect it to the application.
Output: Working end-to-end pipeline that processes documents and produces findings.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-numeric-validation/DISCOVERY.md
@.planning/phases/03-numeric-validation/03-01-PLAN.md
@.planning/phases/03-numeric-validation/03-02-PLAN.md
@backend/app/models/finding.py
@backend/app/models/job.py
@backend/app/services/agents/planner.py
@backend/app/services/agents/validator.py

**Tech stack available:**
- SequentialAgent for pipeline orchestration
- Planner (output_key=fslis) → Validator (output_key=validation_results) → Manager
- Finding model with category, severity, description, source_refs, reasoning, agent_id

**Pattern from DISCOVERY.md:**
```python
pipeline = SequentialAgent(
    name="NumericValidationPipeline",
    sub_agents=[planner, validator, manager]
)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Manager agent for aggregation and finding generation</name>
  <files>backend/app/services/agents/manager.py</files>
  <action>
1. Create manager.py with ManagerAgent:
   - Import LlmAgent from google.adk.agents
   - Define MANAGER_INSTRUCTION constant:
     * You are a financial audit manager
     * You receive validation results from {validation_results}
     * Your job is to:
       - Filter out valid results (is_valid=true)
       - For invalid results, create findings with:
         * category: "numeric"
         * severity: "high" if discrepancy > 10%, "medium" if > 5%, "low" otherwise
         * description: Clear explanation of the issue
         * source_refs: Reference to FSLI and values
         * reasoning: Why this is flagged as an issue
       - Deduplicate findings (same FSLI, same issue = one finding)
     * Output JSON array of findings matching the Finding model structure
   - Create function create_manager_agent() -> LlmAgent:
     * name="ManagerAgent"
     * model="gemini-3-pro"
     * instruction=MANAGER_INSTRUCTION
     * output_key="findings"
2. Export create_manager_agent from agents/__init__.py

Avoid: Don't add code_executor - manager only does reasoning/formatting. Don't try to save to database here - that's the service layer's job.
  </action>
  <verify>python -c "from app.services.agents.manager import create_manager_agent; a = create_manager_agent(); print(a.name, a.output_key)" shows ManagerAgent findings</verify>
  <done>Manager agent created, reads validation_results, outputs findings array</done>
</task>

<task type="auto">
  <name>Task 2: Create SequentialAgent pipeline orchestrator</name>
  <files>backend/app/services/agents/pipeline.py</files>
  <action>
1. Create pipeline.py with NumericValidationPipeline:
   - Import SequentialAgent from google.adk.agents
   - Import InMemoryRunner from google.adk.runners
   - Import agent creators from planner, validator, manager
   - Create class NumericValidationPipeline:
     * __init__(self): creates planner, validator, manager agents
     * Creates SequentialAgent with sub_agents=[planner, validator, manager]
     * name="NumericValidationPipeline"
   - Create async method run(self, extracted_text: str) -> list[dict]:
     * Creates InMemoryRunner with the pipeline agent
     * Runs with user_message=extracted_text
     * Extracts findings from session.state['findings']
     * Returns parsed findings list
2. Export NumericValidationPipeline from agents/__init__.py

Avoid: Don't implement database persistence here - keep pipeline pure. Don't add error handling complexity yet - get happy path working first.
  </action>
  <verify>python -c "from app.services.agents.pipeline import NumericValidationPipeline; p = NumericValidationPipeline(); print(p.pipeline.name)" shows NumericValidationPipeline</verify>
  <done>Pipeline orchestrates Planner → Validator → Manager, returns findings list</done>
</task>

<task type="auto">
  <name>Task 3: Integrate pipeline into document processing service</name>
  <files>backend/app/services/processor.py, backend/app/api/routes/documents.py</files>
  <action>
1. Create backend/app/services/processor.py:
   - Import NumericValidationPipeline, async SQLAlchemy session, models
   - Create class DocumentProcessor:
     * __init__(self, db: AsyncSession)
     * async method process_document(self, job_id: UUID, extracted_text: str):
       - Update job status to "processing"
       - Create NumericValidationPipeline instance
       - Run pipeline with extracted_text
       - For each finding in results:
         * Create Finding model instance
         * Set job_id, category, severity, description, source_refs, reasoning
         * Set agent_id="NumericValidationPipeline"
         * Add to session
       - Commit findings to database
       - Update job status to "completed"
       - Handle exceptions: update job status to "failed", set error_message
2. Update backend/app/api/routes/documents.py:
   - Import DocumentProcessor
   - In the background task (from Phase 2), after extraction:
     * Call DocumentProcessor.process_document(job_id, extracted_text)
   - This chains: upload → extract → validate (all in background)
3. Export DocumentProcessor from services/__init__.py

Avoid: Don't add WebSocket updates yet (Phase 7). Don't add parallel agent execution yet (single pipeline for now).
  </action>
  <verify>Backend starts without errors: cd backend && python -c "from app.services.processor import DocumentProcessor"</verify>
  <done>Document upload triggers extraction → validation pipeline → findings saved to DB</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] backend/app/services/agents/manager.py exists
- [ ] backend/app/services/agents/pipeline.py exists with SequentialAgent
- [ ] backend/app/services/processor.py exists with DocumentProcessor
- [ ] Pipeline chain: Planner (fslis) → Validator (validation_results) → Manager (findings)
- [ ] Document upload triggers full processing pipeline
- [ ] Findings saved to database with correct schema
</verification>

<success_criteria>
- All tasks completed
- End-to-end flow: upload → extract → planner → validator → manager → findings in DB
- Job status updated throughout processing
- Phase 3 complete: Numeric Validation pipeline operational
</success_criteria>

<output>
After completion, create `.planning/phases/03-numeric-validation/03-03-SUMMARY.md`:

# Phase 03 Plan 03: Manager Agent + Pipeline Integration Summary

**[Substantive one-liner about what was built]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- [Key outcome 3]

## Files Created/Modified

- `backend/app/services/agents/manager.py` - Description
- `backend/app/services/agents/pipeline.py` - Description
- `backend/app/services/processor.py` - Description
- `backend/app/api/routes/documents.py` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 3 complete, ready for Phase 4: Logic Consistency
</output>
