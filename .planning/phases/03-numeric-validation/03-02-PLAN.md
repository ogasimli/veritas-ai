---
phase: 03-numeric-validation
plan: 03-02
type: execute
domain: agents
---

<objective>
Create the FanOutVerifierAgent (CustomAgent) that dynamically spawns parallel VerifierAgents, one per FSLI, to perform numeric verification checks.

Purpose: Enable parallel verification of each FSLI for improved accuracy and performance.
Output: FanOutVerifierAgent that reads FSLI names from Extractor, spawns parallel Verifiers, and aggregates check results.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-numeric-validation/DISCOVERY.md
@.planning/phases/03-numeric-validation/03-RESEARCH.md
@.planning/phases/03-numeric-validation/03-01-PLAN.md
@backend/agents/numeric_validation/sub_agents/extractor/agent.py

**Tech stack available:**
- google-adk with BaseAgent, ParallelAgent, LlmAgent
- BuiltInCodeExecutor for math verification
- Extractor agent outputs fsli_names to session.state['extractor_output']

**Critical patterns from RESEARCH.md:**
- CustomAgent extends BaseAgent, creates ParallelAgent inside _run_async_impl()
- Must create fresh agent instances (single-parent rule)
- Yield events from ParallelAgent to preserve ADK observability
- Use prefixed state keys like "checks:{fsli_name}" to prevent collisions

**Constraining decisions:**
- BuiltInCodeExecutor can ONLY be used by itself in an agent
- Each VerifierAgent focuses on ONE FSLI
- Verifier identifies and runs checks, outputs pass/fail results
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VerificationCheck schema and VerifierAgent output</name>
  <files>backend/agents/numeric_validation/sub_agents/fan_out_verifier/schema.py</files>
  <action>
1. Create directory: backend/agents/numeric_validation/sub_agents/fan_out_verifier/
2. Create schema.py with verification schemas:
   ```python
   from typing import List
   from pydantic import BaseModel

   class VerificationCheck(BaseModel):
       fsli_name: str
       check_type: str              # "in_table_sum" | "cross_table_consistency"
       description: str             # What was checked
       expected_value: float
       actual_value: float
       result: str                  # "pass" | "fail"
       source_refs: List[str]       # ["Table 4, Row 12", "Note 5"]
       code_executed: str           # Python code used for verification

   class VerifierAgentOutput(BaseModel):
       checks: List[VerificationCheck]
   ```

Avoid: Don't add severity here - Reviewer assigns severity later.
  </action>
  <verify>python -c "from agents.numeric_validation.sub_agents.fan_out_verifier.schema import VerificationCheck, VerifierAgentOutput; print('schema ok')"</verify>
  <done>Verification schemas defined with all required fields</done>
</task>

<task type="auto">
  <name>Task 2: Create Verifier prompt and factory function</name>
  <files>backend/agents/numeric_validation/sub_agents/fan_out_verifier/prompt.py, backend/agents/numeric_validation/sub_agents/fan_out_verifier/verifier.py</files>
  <action>
1. Create prompt.py with get_verifier_instruction(fsli_name) function:
   ```python
   def get_verifier_instruction(fsli_name: str) -> str:
       return f"""You are a financial numeric verifier analyzing: {fsli_name}

   Your task is to find and verify all numeric relationships for this FSLI in the document.

   ## Verification Types

   1. **In-table sum verification** (check_type: "in_table_sum"):
      - Check if component line items sum to this total
      - Example: "Revenue = Product Revenue + Service Revenue"
      - Example: "Total Assets = Current Assets + Non-current Assets"

   2. **Cross-table consistency** (check_type: "cross_table_consistency"):
      - Check if this FSLI appears in multiple tables with matching values
      - Example: "Net Income in Income Statement matches Net Income in Cash Flow"

   ## Instructions

   1. Search the document for all occurrences of "{fsli_name}"
   2. For each occurrence, identify what can be verified mathematically
   3. Use Python code execution to perform ALL calculations
   4. Report each check with pass/fail result

   ## Code Execution Requirements

   - Use Python for ALL mathematical verification
   - Extract values from the document context
   - Perform calculations deterministically
   - Include the code you executed in your output

   Output your findings as structured VerificationCheck objects.
   """
   ```

2. Create verifier.py with factory function:
   ```python
   from google.adk.agents import LlmAgent
   from google.adk.code_executors import BuiltInCodeExecutor
   from .schema import VerifierAgentOutput
   from .prompt import get_verifier_instruction

   def create_verifier_agent(
       name: str,
       fsli_name: str,
       output_key: str
   ) -> LlmAgent:
       """
       Factory to create a fresh VerifierAgent for a specific FSLI.
       Must create new instances each time (ADK single-parent rule).
       """
       return LlmAgent(
           name=name,
           model="gemini-3-pro-preview",
           instruction=get_verifier_instruction(fsli_name),
           output_key=output_key,
           output_schema=VerifierAgentOutput,
           code_executor=BuiltInCodeExecutor(),
       )
   ```

Avoid: Don't add other tools - code_executor must be exclusive.
  </action>
  <verify>python -c "from agents.numeric_validation.sub_agents.fan_out_verifier.verifier import create_verifier_agent; a = create_verifier_agent('test', 'Revenue', 'checks:Revenue'); print(a.name)"</verify>
  <done>Verifier prompt and factory function created</done>
</task>

<task type="auto">
  <name>Task 3: Create FanOutVerifierAgent (CustomAgent)</name>
  <files>backend/agents/numeric_validation/sub_agents/fan_out_verifier/agent.py, backend/agents/numeric_validation/sub_agents/fan_out_verifier/__init__.py</files>
  <action>
1. Create agent.py with FanOutVerifierAgent:
   ```python
   """FanOutVerifierAgent - CustomAgent for dynamic parallel verification."""
   from typing import AsyncGenerator
   from google.adk.agents import BaseAgent, ParallelAgent
   from google.adk.events import Event
   from google.adk.agents.invocation_context import InvocationContext
   from google.genai import types

   from .verifier import create_verifier_agent


   class FanOutVerifierAgent(BaseAgent):
       """
       CustomAgent that dynamically spawns parallel VerifierAgents,
       one per FSLI extracted by ExtractorAgent.

       Maintains ADK observability by using ParallelAgent internally.
       """

       name: str = "FanOutVerifierAgent"
       description: str = "Spawns parallel verifiers for each FSLI"

       async def _run_async_impl(
           self,
           ctx: InvocationContext
       ) -> AsyncGenerator[Event, None]:
           # 1. Read FSLI names from session state (set by ExtractorAgent)
           extractor_output = ctx.session.state.get("extractor_output", {})
           fsli_names = extractor_output.get("fsli_names", [])

           if not fsli_names:
               yield Event(
                   author=self.name,
                   content=types.Content(
                       role="agent",
                       parts=[types.Part(text="No FSLIs found to verify.")]
                   )
               )
               return

           # 2. Create fresh VerifierAgent instances (single-parent rule)
           verifier_agents = [
               create_verifier_agent(
                   name=f"verify_{fsli_name.replace(' ', '_').replace('/', '_')}",
                   fsli_name=fsli_name,
                   output_key=f"checks:{fsli_name}"
               )
               for fsli_name in fsli_names
           ]

           # 3. Wrap in ParallelAgent for concurrent execution
           parallel = ParallelAgent(
               name="verifier_parallel_block",
               sub_agents=verifier_agents
           )

           # 4. Yield all events (preserves ADK observability)
           async for event in parallel.run_async(ctx):
               yield event


   # Singleton instance for import
   fan_out_verifier_agent = FanOutVerifierAgent()
   ```

2. Create __init__.py:
   ```python
   """FanOutVerifier sub-agent exports."""
   from .agent import fan_out_verifier_agent, FanOutVerifierAgent
   from .verifier import create_verifier_agent
   from .schema import VerificationCheck, VerifierAgentOutput
   ```

Avoid: Don't use asyncio.gather - use ParallelAgent to preserve ADK observability.
  </action>
  <verify>python -c "from agents.numeric_validation.sub_agents.fan_out_verifier import fan_out_verifier_agent; print(fan_out_verifier_agent.name)"</verify>
  <done>FanOutVerifierAgent CustomAgent created with dynamic parallelism</done>
</task>

<task type="auto">
  <name>Task 4: Update root agent to include FanOutVerifierAgent</name>
  <files>backend/agents/numeric_validation/agent.py, backend/agents/numeric_validation/sub_agents/__init__.py</files>
  <action>
1. Update sub_agents/__init__.py:
   ```python
   """Sub-agents for numeric validation."""
   from .extractor import extractor_agent
   from .fan_out_verifier import fan_out_verifier_agent
   ```

2. Update agent.py:
   ```python
   """Root agent definition."""
   from google.adk.agents import SequentialAgent
   from .sub_agents import extractor_agent, fan_out_verifier_agent

   root_agent = SequentialAgent(
       name='numeric_validation',
       description='Pipeline for financial statement numeric validation',
       sub_agents=[
           extractor_agent,        # Extract FSLI names
           fan_out_verifier_agent, # Parallel verification per FSLI
           # reviewer_agent,       # To be added in 03-03
       ],
   )
   ```

Avoid: Don't add reviewer yet - comes in 03-03.
  </action>
  <verify>python -c "from agents.numeric_validation.agent import root_agent; print(len(root_agent.sub_agents))" shows 2</verify>
  <done>Root agent updated with Extractor → FanOutVerifier pipeline</done>
</task>

<task type="auto">
  <name>Task 5: Add unit tests for FanOutVerifierAgent</name>
  <files>backend/agents/numeric_validation/tests/test_fan_out_verifier.py</files>
  <action>
1. Create test_fan_out_verifier.py:
   ```python
   """Tests for FanOutVerifierAgent."""
   import pytest
   import dotenv
   from google.adk.runners import InMemoryRunner

   from agents.numeric_validation.sub_agents.fan_out_verifier import (
       fan_out_verifier_agent,
       FanOutVerifierAgent,
       create_verifier_agent,
       VerificationCheck,
       VerifierAgentOutput,
   )

   pytest_plugins = ("pytest_asyncio",)

   @pytest.fixture(scope="session", autouse=True)
   def load_env():
       dotenv.load_dotenv()

   def test_fan_out_verifier_agent_structure():
       """Verify FanOutVerifierAgent is a CustomAgent."""
       assert fan_out_verifier_agent.name == "FanOutVerifierAgent"
       assert isinstance(fan_out_verifier_agent, FanOutVerifierAgent)

   def test_create_verifier_agent():
       """Verify verifier factory creates valid agents."""
       agent = create_verifier_agent(
           name="test_verifier",
           fsli_name="Revenue",
           output_key="checks:Revenue"
       )
       assert agent.name == "test_verifier"
       assert agent.model == "gemini-3-pro-preview"
       assert agent.code_executor is not None

   def test_verification_check_schema():
       """Verify VerificationCheck schema."""
       check = VerificationCheck(
           fsli_name="Revenue",
           check_type="in_table_sum",
           description="Product + Service = Total Revenue",
           expected_value=1500000.0,
           actual_value=1500000.0,
           result="pass",
           source_refs=["Table 4, Row 12"],
           code_executed="1000000 + 500000 == 1500000"
       )
       assert check.result == "pass"

   def test_verifier_agent_output_schema():
       """Verify VerifierAgentOutput schema."""
       output = VerifierAgentOutput(checks=[])
       assert output.checks == []
   ```

Avoid: Don't test actual LLM calls in unit tests - just structure validation.
  </action>
  <verify>cd backend && export PYTHONPATH=$(pwd) && ./.venv/bin/pytest agents/numeric_validation/tests/test_fan_out_verifier.py -v</verify>
  <done>Unit tests pass for FanOutVerifierAgent structure</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] backend/agents/numeric_validation/sub_agents/fan_out_verifier/ exists with all files
- [ ] FanOutVerifierAgent extends BaseAgent (CustomAgent pattern)
- [ ] create_verifier_agent() factory creates LlmAgent with code_executor
- [ ] VerificationCheck schema has all required fields
- [ ] Root agent has 2 sub-agents: Extractor → FanOutVerifier
- [ ] **Unit Tests**: `export PYTHONPATH=$(pwd) && ./.venv/bin/pytest agents/numeric_validation/tests` passes
- [ ] **ADK Run**: `export PYTHONPATH=$(pwd) && ./.venv/bin/adk run agents/numeric_validation` works
</verification>

<success_criteria>
- All tasks completed
- FanOutVerifierAgent dynamically creates parallel VerifierAgents
- Each VerifierAgent uses BuiltInCodeExecutor for math verification
- ADK observability preserved via event yielding
- Unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-numeric-validation/03-02-SUMMARY.md`:

# Phase 03 Plan 02: FanOutVerifierAgent Summary

**[Substantive one-liner about what was built]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- [Key outcome 3]

## Files Created/Modified

- `backend/agents/numeric_validation/sub_agents/fan_out_verifier/agent.py` - FanOutVerifierAgent CustomAgent
- `backend/agents/numeric_validation/sub_agents/fan_out_verifier/verifier.py` - Verifier factory function
- `backend/agents/numeric_validation/sub_agents/fan_out_verifier/prompt.py` - Verifier instruction generator
- `backend/agents/numeric_validation/sub_agents/fan_out_verifier/schema.py` - VerificationCheck schema
- `backend/agents/numeric_validation/agent.py` - Updated root agent

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 03-03-PLAN.md (ReviewerAgent with code_executor for re-verification and findings output)
</output>
