---
phase: 03-numeric-validation
plan: 03-02
type: execute
domain: agents
---

<objective>
Create the Validator agent with BuiltInCodeExecutor that performs deterministic math verification on FSLIs.

Purpose: Core numeric validation - verify that financial calculations are mathematically correct.
Output: Validator agent that generates and executes Python code to verify FSLI math.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-numeric-validation/DISCOVERY.md
@.planning/phases/03-numeric-validation/03-01-PLAN.md
@backend/app/services/agents/planner.py

**Tech stack available:**
- google-adk with BuiltInCodeExecutor
- Planner agent outputs FSLIs to session.state['fslis']

**Critical constraint from DISCOVERY.md:**
- BuiltInCodeExecutor can ONLY be used by itself in an agent
- Cannot combine with other tools
- Sandbox has numpy, pandas available

**Pattern:**
```python
from google.adk.code_executors import BuiltInCodeExecutor

validator = LlmAgent(
    name="Validator",
    model="gemini-3-pro",
    code_executor=BuiltInCodeExecutor(),
    instruction="...",
    output_key="validation_results"
)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Validator agent with code_executor</name>
  <files>backend/app/services/agents/validator.py</files>
  <action>
1. Create validator.py with ValidatorAgent:
   - Import BuiltInCodeExecutor from google.adk.code_executors
   - Import LlmAgent from google.adk.agents
   - Define VALIDATOR_INSTRUCTION constant:
     * You are a financial math validator
     * You receive FSLIs from {fslis} (JSON array of financial line items)
     * Perform TWO types of validation:
       1. **Sum verification**: For each FSLI with multiple values, write Python code to:
          - Extract the values
          - Verify any apparent calculations (e.g., sum, percentage, YoY change)
          - Check if component parts sum to totals
       2. **Cross-table consistency**: If the same FSLI name appears in multiple tables:
          - Compare values across all occurrences
          - Flag any discrepancies (same FSLI should have same value everywhere)
     * Use pandas for table operations if needed
     * Output JSON array of validation results: [{fsli_name, check_type, expected, actual, is_valid, discrepancy, code_used, table_refs}]
   - Create function create_validator_agent() -> LlmAgent:
     * name="ValidatorAgent"
     * model="gemini-3-pro"
     * code_executor=BuiltInCodeExecutor()
     * instruction=VALIDATOR_INSTRUCTION
     * output_key="validation_results"
2. Export create_validator_agent from agents/__init__.py

Avoid: Don't add any other tools - code_executor must be alone. Don't try to format findings yet - that's Manager's job. Keep the instruction focused on math verification only.
  </action>
  <verify>python -c "from app.services.agents.validator import create_validator_agent; a = create_validator_agent(); print(a.name, hasattr(a, 'code_executor'))" shows ValidatorAgent True</verify>
  <done>Validator agent created with BuiltInCodeExecutor, reads from {fslis}, outputs to validation_results</done>
</task>

<task type="auto">
  <name>Task 2: Add validation result types and test harness</name>
  <files>backend/app/schemas/validation.py, backend/app/services/agents/__init__.py</files>
  <action>
1. Create backend/app/schemas/validation.py:
   - Define ValidationResult Pydantic model:
     * fsli_name: str
     * check_type: str (e.g., "sum_check", "percentage_check", "yoy_change", "cross_table_consistency")
     * expected: float | None
     * actual: float | None
     * is_valid: bool
     * discrepancy: float | None
     * code_used: str | None
   - Define FSLIItem Pydantic model:
     * name: str
     * values: list[dict]  # [{label, amount, unit}]
     * source_ref: str | None
2. Update agents/__init__.py to export both agent creators

Avoid: Don't over-engineer the schemas - these are for validation results, not database models. The Finding model handles persistence.
  </action>
  <verify>python -c "from app.schemas.validation import ValidationResult, FSLIItem; print('schemas ok')" runs without error</verify>
  <done>Validation schemas defined, agent exports updated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] backend/app/services/agents/validator.py exists with BuiltInCodeExecutor
- [ ] backend/app/schemas/validation.py has ValidationResult and FSLIItem models
- [ ] Validator agent reads from {fslis} template variable
- [ ] Validator agent writes to output_key="validation_results"
- [ ] All imports work
</verification>

<success_criteria>
- All tasks completed
- Validator agent configured with code_executor (no other tools)
- Validation result schema ready for downstream processing
- Planner â†’ Validator state flow established via {fslis}
</success_criteria>

<output>
After completion, create `.planning/phases/03-numeric-validation/03-02-SUMMARY.md`:

# Phase 03 Plan 02: Validator Agent Summary

**[Substantive one-liner about what was built]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `backend/app/services/agents/validator.py` - Description
- `backend/app/schemas/validation.py` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 03-03-PLAN.md (Manager agent and pipeline orchestration)
</output>
