---
phase: 08-backend-websocket-support
plan: 8-01-FIX
type: fix
---

<objective>
Fix 1 UAT blocker issue from Phase 8 Plan 1.

Source: 8-01-ISSUES.md
Priority: 1 blocker (prevents end-to-end verification of WebSocket functionality)

Purpose: Implement real frontend API integration to replace mock functions, enabling complete audit processing flow with WebSocket updates. This unblocks end-to-end testing of the Phase 8 WebSocket implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/08-backend-websocket-support/8-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/08-backend-websocket-support/8-01-PLAN.md

**Backend API context:**
@backend/app/api/routes/documents.py
@backend/app/schemas/job.py

**Frontend code to fix:**
@frontend/lib/api.ts
@frontend/app/(dashboard)/audit/new/page.tsx

**Key insight from UAT:**
Phase 8 WebSocket backend is technically correct (endpoint works, ConnectionManager works, messages schemas exist). The gap is that Phase 7 frontend was built with placeholder API functions that log to console but never make actual HTTP requests. This prevents the backend from receiving audit creation, file upload, or processing trigger, so agents never execute and WebSocket never sends messages.

**Backend API available:**
- POST /documents/upload - Accepts .docx file, creates Job and Document records, triggers background processing
- Returns JobRead schema with job.id (UUID)
- Backend automatically processes document and streams WebSocket updates to /ws/audit/{job_id}

**Frontend needs to:**
1. Call backend POST /documents/upload with file
2. Get job.id from response
3. Connect WebSocket to /ws/audit/{job.id}
4. Listen for agent_started, agent_completed, audit_complete messages
</context>

<tasks>

<task type="auto">
  <name>Fix UAT-001: Implement real API functions in frontend/lib/api.ts</name>
  <files>frontend/lib/api.ts</files>
  <action>
  Replace mock implementations with real API calls:

  1. Remove createAudit() function entirely - backend creates audit automatically when file is uploaded

  2. Replace uploadFile() with real implementation:
     - Create FormData with file
     - POST to http://localhost:8000/documents/upload (use NEXT_PUBLIC_API_URL env var with fallback to localhost:8000)
     - Content-Type: multipart/form-data (browser sets automatically)
     - Handle response: extract job.id from JobRead schema
     - Return job.id (string representation of UUID)
     - Add error handling for network failures and non-200 responses

  3. Remove startProcessing() function - backend starts processing automatically in background task

  4. Update type definitions to match backend schemas:
     - Job has id (UUID), status, created_at, documents[]
     - No separate "audit" entity in backend - Job IS the audit

  Key changes:
  - Backend API is at port 8000, frontend at 3000
  - Use fetch() with proper error handling
  - File upload returns job.id which is used for WebSocket connection
  - Processing starts automatically via BackgroundTasks in backend

  Don't add API key auth or complex retry logic - out of scope for this fix. Just get basic HTTP communication working.
  </action>
  <verify>
  1. TypeScript compiles without errors: cd frontend && npm run build
  2. uploadFile function makes POST request to /documents/upload
  3. Function returns job.id from response
  4. Error handling exists for network failures
  </verify>
  <done>
  - createAudit() and startProcessing() removed (not needed)
  - uploadFile() makes real HTTP POST to backend
  - Returns job.id for WebSocket connection
  - Error handling for fetch failures
  </done>
</task>

<task type="auto">
  <name>Fix UAT-001: Update upload page to use real API flow</name>
  <files>frontend/app/(dashboard)/audit/new/page.tsx</files>
  <action>
  Update handleStartReview() function to match backend API flow:

  1. Remove createAudit() call - backend creates job on upload

  2. Update file upload flow:
     - Call uploadFile(currentYearFile, 'current') which returns job.id
     - Set auditId state to job.id from response
     - Remove TODO comments about file upload (now implemented)

  3. Processing starts automatically in backend, no startProcessing() call needed

  4. WebSocket connection already correct:
     - useAuditWebSocket(auditId) connects to /ws/audit/{auditId}
     - This matches backend endpoint /ws/audit/{audit_id}
     - Messages are already handled by hook

  Flow after fix:
  1. User uploads file
  2. Frontend calls uploadFile() â†’ POST /documents/upload
  3. Backend creates Job, uploads to GCS, triggers background processing
  4. Backend returns job.id
  5. Frontend sets auditId to job.id
  6. useAuditWebSocket connects to /ws/audit/{job.id}
  7. Backend processor streams agent events via WebSocket
  8. Frontend displays real-time updates

  Handle errors from uploadFile() - show user-friendly message if upload fails.
  </action>
  <verify>
  1. TypeScript compiles: cd frontend && npm run build
  2. handleStartReview calls uploadFile() instead of createAudit()
  3. No calls to removed startProcessing() function
  4. auditId set from uploadFile response
  5. Error handling for upload failures exists
  </verify>
  <done>
  - Upload flow uses real backend API
  - auditId comes from backend job.id
  - WebSocket connects with correct audit ID
  - Processing triggered automatically by backend
  - Error handling for failed uploads
  </done>
</task>

<task type="auto">
  <name>Fix UAT-001: Add API_URL environment variable configuration</name>
  <files>frontend/.env.local</files>
  <action>
  Create .env.local if it doesn't exist, add:

  NEXT_PUBLIC_API_URL=http://localhost:8000

  This allows easy configuration of backend URL. Frontend code should use:
  const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'

  NEXT_PUBLIC_ prefix makes it available in browser (Next.js requirement).

  Note: .env.local is gitignored by default in Next.js projects - that's correct. Add .env.example with placeholder if desired for documentation.
  </action>
  <verify>
  1. File exists: frontend/.env.local
  2. Contains NEXT_PUBLIC_API_URL variable
  3. Frontend can read process.env.NEXT_PUBLIC_API_URL
  </verify>
  <done>
  - Environment variable configured for API URL
  - Easy to change for different environments
  - Follows Next.js NEXT_PUBLIC_ convention
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All TypeScript files compile without errors (npm run build)
- [ ] uploadFile() makes real HTTP POST request
- [ ] Upload page flow uses backend API
- [ ] Environment variable configured
- [ ] Can upload file and trigger backend processing
- [ ] WebSocket receives messages (test manually or with Playwright)
</verification>

<success_criteria>

- All UAT issues from 8-01-ISSUES.md addressed
- Frontend makes real API calls to backend
- File upload triggers backend processing
- WebSocket integration works end-to-end
- Agent cards update in real-time during processing
- Ready for re-verification with /gsd:verify-work
</success_criteria>

<output>
After completion, create `.planning/phases/08-backend-websocket-support/8-01-FIX-SUMMARY.md` and update 8-01-ISSUES.md to move UAT-001 to Resolved Issues section.
</output>
